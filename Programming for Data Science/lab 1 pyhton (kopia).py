import math# Exercise 1    def circumference(radius=1):    circumference = 2 * math.pi * radius    return circumference# Exercise 2def area(radius):    area = math.pi * (radius ** 2)    return area# Exercise 3def circle_properties(radius, properties="area"):    circle_properties = 1*(properties=="area")*area(radius) + 1*(properties!="area")*circumference(radius)    return(circle_properties)# Exercise 4def sphere_properties(radius, properties = "volume", properties_2 = "area"):  sphere_properties =  (      1*(properties=="volume")*(4/3*math.pi*radius**3)+       1*(properties!="volume")*(properties_2=="area")*area(radius)+       1*(properties!="volume")*(properties_2!="area")*circumference(radius)  )  return(sphere_properties)# Exercise 5def circle_properties_if_else(radius, circumference = False):    if circumference:        return circumference    else:        return areadef sphere_properties_if_else (radius, volume = True):    if volume:        return 4/3*math.pi*radius^3    else:        return circle_properties# Exercise 6from math import exp, logn = 100z = 1y = 2interval = y - z  delta_x = interval / nlower_bound = 0 for i in range(n):    xi = z+i*delta_x    lower_bound = lower_bound + (exp(xi) + log(xi))*delta_xlower_bound    upper_bound = 0 for i in range(n):    xi = z + i*delta_x    xi_1 = xi + delta_x    upper_bound = upper_bound + (exp(xi_1) + log(xi_1))*delta_xupper_bound        error = upper_bound - lower_bounderror# Exercise 7error_treshold = 0.0001while error > error_treshold:    error = 1/n * abs((log(z)+exp(z))-(log(y)+exp(y)))    n+=100    print(error)# Exercise 8def riemann_sum_with_log_constraint():    num_terms = 100    interval = 1      delta_x = interval / num_terms    result = 0.0    for i in range(num_terms):        x = i * delta_x        if math.log(x) < -1:            break        result += (math.exp(x) + math.log(x)) * delta_x    return(result)# Exercise 9import datetime  days = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]start_date = datetime.date(2023, 1, 1)end_date = datetime.date(2023, 12, 31)date_list = []for i in range((end_date - start_date).days + 1):    current_date = start_date + datetime.timedelta(days=i)    day_of_week = current_date.strftime("%A")    date_list.append(day_of_week)print(date_list)# Exercise 10week = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]year = [week]*53week[0:7] = 'su', 'mo','tu','we','th','fr','sa' yearyear[-1]='su'year# 52*7+1 = 365# Exercise 11#(If the list of weeks is created by replication of values, changing one week #would affect all weeks since they share the same underlying object. This can be #problematic if you want different weeks to have different names. Changing by #address or using a separate list for each week would be a better approach. #However, the benefit of replication is that it consumes less memory since it #doesn't create separate objects for each week.